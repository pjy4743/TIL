# 01. 몇 가지 기초 사항들
## 알고리즘(Algorithm)
어떤 작업을 수행하기 위해 `입력`을 받아 원하는 `출력`을 만들어내는 과정을 기술한 것
### 알고리즘 설계 고려사항
 해야 할 작업을 명확하게 명시
 `입력`과 `출력`에 의해 알고리즘이 `무엇`을 하는지 명시

### 알고리즘의 예
학생 100명의 시험점수를 입력으로 받아 최고점을 출력하는 작업
* 입력 : 100개의 점수
* 출력 : 입력된 100개의 점수 중 최대값

조금 더 구체적으로 표현하면,
* 입력 : 100개의 변수 x[1], ... , x[100]의 값
* 출력 : x[1], ... , x[100] 중 최대값

위의 내용을 알고리즘으로 표현하면,
```java
maxScore(x[], n)
{
    x[1...n]의 값을 차례대로 보면서 최대값을 계산;
    return 위에서 찾은 최대값;
}
```
실제 알고리즘을 만들 때, `구체화 과정`을 거쳐 모호함이 없는 수준에서 마무리함
> 함수나 서브루틴이 이 구체화 과정에서 도입

### 잘 설계된 알고리즘
#### 명확성
모호하지 않고 이해하기 쉬운 정도
특정 프로그래밍 언어로 변환하는 데 어려움이 없어야 함
과한 세부사항 설명을 지양 **(자세함 ≠ 명확성)**
읽는 사람의 수준에 맞는 표현을 사용
#### 효율성
**입력의 크기가 충분히 큰 문제**에 대해, `수행 시간`이 작아야 함
> 컴퓨터의 빠른 처리 능력으로 인해 작은 입력에 대한 처리 시간은 고려되지 않음

### 점근적 분석(Asymptotic Analysis)
입력이 충분히 큰 경우에 대한 분석
알고리즘을 명확하고 효율적으로 설계하고, 알고리즘의 효율성을 분석하는 작업

### 알고리즘을 분석하는 이유
#### 시간 분석
알고리즘을 설계하고 자원의 소모 정도를 분석해야 함
여기서 자원은 `소요시간`으로 한정함
> 메모리, 통신 대역 등 다른 자원 대부분은 주어진 범위 내에서 문제가 되지 않음

`최악의 경우`와 `평균적인 경우`에 대한 분석
**입력에 대한 소요시간을 어느 정도 짐작할 수 있음**

### 알고리즘의 수행시간
**입력의 크기**에 대해 **시간의 소요 비율**을 표현

#### 상수 시간이 소요되는 알고리즘
입력의 크기가 n인 경우에 대한 알고리즘
```java
sample1(A[], n)
{
    k = ⌊n/2⌋;
    return A[k];
}
```
|작업|소요시간|
|:--:|:--:|
|⌊n/2⌋ 계산</br>A[⌊n/2⌋] 출력|상수 시간|

#### 입력의 크기 n에 비례하는 시간이 소요되는 알고리즘
A[1 ... n]의 모든 원소를 더하는 알고리즘
```java
sample2(A[], n) {
    sum ← 0;
    for i ← 1 to n
        sum ← sum + A[i];
    return sum;
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n만큼 작업 반복|n에 비례|
|sum + A[i]|단순 덧셈|상수 시간|

#### n²에 비례하는 알고리즘
 A[1 ... n]의 모든 원소쌍을 곱한 합을 구하는 알고리즘
 ```java
 sample3(A[], n)
 {
    sum ← 0;
    for i ← 1 to n
        for j ← 1 to n    
            sum ← sum + A[i] * A[j];
    return sum;
 }
 ```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n * n = n²</br>만큼 작업 반복|n²에 비례|
|sum + A[i] * A[j]|단순 덧셈 곱셈|상수 시간|

#### n³에 비례하는 알고리즘
for루프를 n² 반복하면서 매번 배열에서 반을 임의로 뽑아 그 중 최대값을 계속 더하는 알고리즘
```java
sample4(A[], n)
{
    sum ← 0;
    for i ← 1 to n
        for j ← 1 to n {    
            k ← A[1 ... n]에서 임의로 ⌊n/2⌋개를 뽑을 때 이들 중 최대값;
            sum ← sum + k;
        }
    return sum;
}
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n * n = n²</br>만큼 작업 반복|n²에 비례|
|A[1 ... n]에서 임의로 ⌊n/2⌋개를 뽑을 때 이들 중 최대값|n/2개 뽑기|n/2에 비례|
|sum + k|단순 덧셈|상수 시간|

#### 반복 횟수가 매번 변하는 알고리즘
배열 A[1 ... n]에서 i < j인 모든 원소쌍의 곱을 합산하는 알고리즘
```java
sample5(A[], n)
{
    sum ← 0;
    for i ← 1 to n - 1
        for j ← i + 1 to n
            sum ← sum + A[i] * A[j];
    return sum;
}
``` 
||작업|소요시간|
|:---:|:---:|:---:|
|for|{n(n-1)}/2만큼 작업 반복|n²에 비례|
|sum + A[i] * A[j]|단순 덧셈 곱셈|상수 시간|
> i=2일 때 n-2회 반복, i=3일 때 n-3회 반복... i=n-1일 때 1회 반복

#### 자기 호출 알고리즘
```java
factorial(n)
{
    if(n=1) return 1;
    return n * factorial(n-1);
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|if(n=1) return 1;|단순 상수 반환|상수 시간|
|n * factorial(n-1)|n!-1만큼 작업 반복|n에 비례|

### 재귀(자기호출)과 귀납적 사고
어떤 문제를 해결하는 과정에서 **자신과 똑같지만 크기가 다른 문제**를 발견하고 이들의 **관계를 파악**함으로써 문제 해결에 간명하게 접근하는 방식으로, 수열의 `점화식`, `수학적 귀납법`과 관련됨

**자신보다 작은 문제**에 대해 알고리즘이 제대로 작동한다고 **가정**

#### 재귀 알고리즘을 이용한 병합 정렬
```java
mergeSort(A[], p, r)
▷ A[p ... r]을 정렬한다.
{
    if(p < r) then {
        q ← ⌊(p + r)/2⌋;            ▷ p, r의 중간 지점 계산
        mergeSort(A, p, q);         ▷ 전반부 정렬
        mergeSort(A, q + 1, r);     ▷ 후반부 정렬
        merge(A, p, q, r);          ▷ 병합
    }
}

merge(A[], p, q, r)
{
    정렬되어 있는 두 배열 A[p ... q]와 A[q + 1 ... r]을 합쳐
    정렬된 하나의 배열 A[p ... r]을 만든다.
}
```
|code|설명|특징|
|:--:|:--:|:--:|
|q ← ⌊(p + r)/2⌋;|정렬하고자 하는 배열의 중간 지점을 계산해 전체 배열 이등분||
|mergeSort(A, p, q);|이등분된 배열의 전반부 정렬|Recursion(자기호출)|
|mergeSort(A, q + 1, r);|이등분된 배열의 후반부 정렬|Recursion(자기호출)|
|merge(A, p, q, r);|정렬된 두 배열을 합쳐 하나의 정렬된 배열 생성||

### 알고리즘으로 해결 가능한 문제
|문제|알고리즘|
|:--:|:--:|
|네비게이션|최단경로 알고리즘|
|현금자동입출기(ATM)|스케줄링|
|인간지놈 프로젝트|서열간의 유사성 파악</br>최적의 진화 계통도 제작|
|인터넷 서칭|검색 알고리즘|
|신용카드 사용내역 발송|정렬 알고리즘|
|제품 제작 공정|위상정렬|
|가스 파이프, 수도관 배치|최소신장트리|
|반도체의 게이트|유전 알고리즘, 동적 스케줄링...|
