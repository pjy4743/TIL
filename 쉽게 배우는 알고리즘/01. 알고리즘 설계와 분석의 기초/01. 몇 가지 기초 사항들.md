# 01. 몇 가지 기초 사항들
## 알고리즘(Algorithm)
어떤 작업을 수행하기 위해 `입력`을 받아 원하는 `출력`을 만들어내는 과정을 기술한 것
### 알고리즘 설계 고려사항
 해야 할 작업을 명확하게 명시
 `입력`과 `출력`에 의해 알고리즘이 `무엇`을 하는지 명시

### 알고리즘의 예
학생 100명의 시험점수를 입력으로 받아 최고점을 출력하는 작업
* 입력 : 100개의 점수
* 출력 : 입력된 100개의 점수 중 최대값

조금 더 구체적으로 표현하면,
* 입력 : 100개의 변수 x[1], ... , x[100]의 값
* 출력 : x[1], ... , x[100] 중 최대값

위의 내용을 알고리즘으로 표현하면,
```java
maxScore(x[], n)
{
    x[1...n]의 값을 차례대로 보면서 최대값을 계산;
    return 위에서 찾은 최대값;
}
```
실제 알고리즘을 만들 때, `구체화 과정`을 거쳐 모호함이 없는 수준에서 마무리함
> 함수나 서브루틴이 이 구체화 과정에서 도입

### 잘 설계된 알고리즘
#### 명확성
모호하지 않고 이해하기 쉬운 정도
특정 프로그래밍 언어로 변환하는 데 어려움이 없어야 함
과한 세부사항 설명을 지양 **(자세함 ≠ 명확성)**
읽는 사람의 수준에 맞는 표현을 사용
#### 효율성
**입력의 크기가 충분히 큰 문제**에 대해, `수행 시간`이 작아야 함
> 컴퓨터의 빠른 처리 능력으로 인해 작은 입력에 대한 처리 시간은 고려되지 않음

### 점근적 분석(Asymptotic Analysis)
입력이 충분히 큰 경우에 대한 분석
알고리즘을 명확하고 효율적으로 설계하고, 알고리즘의 효율성을 분석하는 작업

### 알고리즘을 분석하는 이유
#### 시간 분석
알고리즘을 설계하고 자원의 소모 정도를 분석해야 함
여기서 자원은 `소요시간`으로 한정함
> 메모리, 통신 대역 등 다른 자원 대부분은 주어진 범위 내에서 문제가 되지 않음

`최악의 경우`와 `평균적인 경우`에 대한 분석
**입력에 대한 소요시간을 어느 정도 짐작할 수 있음**

### 알고리즘의 수행시간
**입력의 크기**에 대해 **시간의 소요 비율**을 표현

#### 상수 시간이 소요되는 알고리즘
입력의 크기가 n인 경우에 대한 알고리즘
```java
sample1(A[], n)
{
    k = ⌊n/2⌋;
    return A[k];
}
```
|작업|소요시간|
|:--:|:--:|
|⌊n/2⌋ 계산</br>A[⌊n/2⌋] 출력|상수 시간|

#### 입력의 크기 n에 비례하는 시간이 소요되는 알고리즘
A[1 ... n]의 모든 원소를 더하는 알고리즘
```java
sample2(A[], n) {
    sum ← 0;
    for i ← 1 to n
        sum ← sum + A[i];
    return sum;
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n만큼 작업 반복|n에 비례|
|sum + A[i]|단순 덧셈|상수 시간|

#### n²에 비례하는 알고리즘
 A[1 ... n]의 모든 원소쌍을 곱한 합을 구하는 알고리즘
 ```java
 sample3(A[], n)
 {
    sum ← 0;
    for i ← 1 to n
        for j ← 1 to n    
            sum ← sum + A[i] * A[j];
    return sum;
 }
 ```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n * n = n²</br>만큼 작업 반복|n²에 비례|
|sum + A[i] * A[j]|단순 덧셈 곱셈|상수 시간|

#### n³에 비례하는 알고리즘
for루프를 n² 반복하면서 매번 배열에서 반을 임의로 뽑아 그 중 최대값을 계속 더하는 알고리즘
```java
sample4(A[], n)
{
    sum ← 0;
    for i ← 1 to n
        for j ← 1 to n {    
            k ← A[1 ... n]에서 임의로 ⌊n/2⌋개를 뽑을 때 이들 중 최대값;
            sum ← sum + k;
        }
    return sum;
}
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|for|n * n = n²</br>만큼 작업 반복|n²에 비례|
|A[1 ... n]에서 임의로 ⌊n/2⌋개를 뽑을 때 이들 중 최대값|n/2개 뽑기|n/2에 비례|
|sum + k|단순 덧셈|상수 시간|

#### 반복 횟수가 매번 변하는 알고리즘
배열 A[1 ... n]에서 i < j인 모든 원소쌍의 곱을 합산하는 알고리즘
```java
sample5(A[], n)
{
    sum ← 0;
    for i ← 1 to n - 1
        for j ← i + 1 to n
            sum ← sum + A[i] * A[j];
    return sum;
}
``` 
||작업|소요시간|
|:---:|:---:|:---:|
|for|{n(n-1)}/2만큼 작업 반복|n²에 비례|
|sum + A[i] * A[j]|단순 덧셈 곱셈|상수 시간|
> i=2일 때 n-2회 반복, i=3일 때 n-3회 반복... i=n-1일 때 1회 반복

#### 자기 호출 알고리즘
```java
factorial(n)
{
    if(n=1) return 1;
    return n * factorial(n-1);
}
```
||작업|소요시간|
|:---:|:---:|:---:|
|if(n=1) return 1;|단순 상수 반환|상수 시간|
|n * factorial(n-1)|n!-1만큼 작업 반복|n에 비례|